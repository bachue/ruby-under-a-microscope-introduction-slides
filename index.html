<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Ruby under a microscope</title>
		<meta name="description" content="Ruby under a microscope introduction">
		<meta name="author" content="Bachue Zhou">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Ruby 2.0</h1>
					<h3>Under a Microscope</h3>
					<p>
						<small>Created by <a href="http://bachue.is-programmer.com">Bachue</a> / <a href="http://twitter.com/iBachue">@iBachue</a></small>
					</p>
					<aside class="notes">
						I'll introduce some points in this book to you.
					</aside>
				</section>

				<section>
					<a href="http://patshaughnessy.net/ruby-under-a-microscope"><img src="img/cover.png" alt="cover of the book" /></a>
					<aside class="notes">
						This book is available to buy on <a href="http://www.nostarch.com/rum">http://www.nostarch.com/rum</a>, price is $31.95.
					</aside>
				</section>

				<section>
					<img src="img/sanya.jpg" />
				</section>

				<section>
					<h3>Who is this book for?</h3>
					<ul>
						<li>Ruby programmer</li>
						<li>No C programming knowledge is required</li>
					</ul>
				</section>

				<section>
					<section>
						<h1>Overview</h1>
						<img src="img/overview.png" />
					</section>
					<section>
						<h1>JRuby</h1>
						<img src="img/jruby-overview.png" />
					</section>
					<section>
						<h1>Rubinius</h1>
						<img src="img/rubinius-overview.png" />
					</section>
				</section>

				<section>
					<section>
						<h1>Tokenize</h1>
						<pre><code>
10.times do |n|
  puts n
end
						</code></pre>
					</section>
					<section>
						<h3>Before</h3>
						<img src="img/before-tokenize.png" />
					</section>
					<section>
						<h3>After</h3>
						<img src="img/after-tokenize.png" />
					</section>
					<section>
						<h3>parser_yylex in parse.y</h3>
						<h4>Keywords: defs/keywords</h4>
						<aside class="notes">
							<p>ruby/parse.y:6693 in `parser_yylex'</p>
							<p>start from line 6968: <code>switch (c = nextc())</code></p>
							<p>keywords: rb_reserved_word, defs/keywords => lex.c</p>
						</aside>
					</section>
					<section>
						<h3>Ripper.lex</h3>
						<pre><code>
require 'ripper'
require 'pp'
code = &lt;&lt;STR
  10.times do |n|
    puts n
  end
STR
pp Ripper.lex(code)
						</code></pre>
						<aside class="notes">
							Ripper allows you to call the same tokenization and parsing code that Ruby uses to process text from code files.
						</aside>
					</section>
					<section>
						<pre><code style="max-height: inherit;">
[[[1, 0], :on_sp, "  "],
 [[1, 2], :on_int, "10"],
 [[1, 4], :on_period, "."],
 [[1, 5], :on_ident, "times"],
 [[1, 10], :on_sp, " "],
 [[1, 11], :on_kw, "do"],
 [[1, 13], :on_sp, " "],
 [[1, 14], :on_op, "|"],
 [[1, 15], :on_ident, "n"],
 [[1, 16], :on_op, "|"],
 [[1, 17], :on_ignored_nl, "\n"],
 [[2, 0], :on_sp, "    "],
 [[2, 4], :on_ident, "puts"],
 [[2, 8], :on_sp, " "],
 [[2, 9], :on_ident, "n"],
 [[2, 10], :on_nl, "\n"],
 [[3, 0], :on_sp, "  "],
 [[3, 2], :on_kw, "end"],
 [[3, 5], :on_nl, "\n"]]
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Phasing</h1>
						<h2>LALR</h2>
						<h2>Bison</h2>
					</section>
					<section>
						<h3>Spanish => English Example</h3>
						<pre><code>
Me gusta el Ruby. => I Like Ruby.
Le gusta el Ruby. => She likes Ruby.
						</code></pre>
					</section>
					<section>
						<h3>Bison/Yacc grammar</h3>
						<pre><code>
SpanishPhrase: VerbAndObject el ruby {
  printf("%s Ruby\n", $1);
};
VerbAndObject: SheLikes | ILike {
  $$ = $1;
};
SheLikes: le gusta {
  $$ = "She likes";
}
ILike: me gusta {
  $$ = "I like";
}
						</code></pre>
					</section>
					<section>
						<h3>Simplified Steps</h3>
						<table style="margin: auto;">
							<tr>
								<th>Grammar Rule Stack</th>
								<th>Tokens</th>
								<th>Action</th>
							</tr>
							<tr>	
								<td></td>
								<td>le gusta el ruby</td>
								<td></td>
							</tr>	
							<tr>	
								<td>le</td>
								<td>gusta el ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>le gusta</td>
								<td>el ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>SheLikes</td>
								<td>el ruby</td>
								<td>Reduce</td>
							</tr>	
							<tr>	
								<td>VerbAndObject</td>
								<td>el ruby</td>
								<td>Reduce</td>
							</tr>	
							<tr>	
								<td>VerbAndObject el</td>
								<td>ruby</td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>VerbAndObject el ruby</td>
								<td></td>
								<td>Shift</td>
							</tr>	
							<tr>	
								<td>SpanishPhrase</td>
								<td></td>
								<td>Match</td>
							</tr>	
						</table>
						<aside class="notes">
							LALR Goto Table
						</aside>
					</section>
					<section>
						<h3>parse.y</h3>
						<aside class="notes">
							<p>parse.y:860</p>
							<a target="_blank" href="/img/ruby-1-4-bnf.pdf">BNF Syntax of Ruby 1.4</a>
						</aside>
					</section>
					<section>
						<h3>ruby -y</h3>
						<pre><code>
10.times do |n|
  puts n
end
						</code></pre>
					</section>
					<section>
						<pre><code>
Starting parse
Entering state 0
Reducing stack by rule 1 (line 782):
-> $$ = nterm @1 ()
Stack now 0
Entering state 2
Reading a token: Next token is token tINTEGER ()
Shifting token tINTEGER ()
Entering state 41
Reducing stack by rule 470 (line 4255):
   $1 = token tINTEGER ()
-> $$ = nterm numeric ()
Stack now 0 2
Entering state 104
Reducing stack by rule 428 (line 3830):
   $1 = nterm numeric ()
-> $$ = nterm literal ()
Stack now 0 2
Entering state 94
Reducing stack by rule 270 (line 2616):
   $1 = nterm literal ()
-> $$ = nterm primary ()
Stack now 0 2
Entering state 80
Reading a token: Next token is token '.' ()
Reducing stack by rule 329 (line 3071):
   $1 = nterm primary ()
-> $$ = nterm primary_value ()
Stack now 0 2
Entering state 81
Next token is token '.' ()
Shifting token '.' ()
Entering state 336
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 533
Reading a token: Next token is token keyword_do ()
Reducing stack by rule 550 (line 4823):
   $1 = token tIDENTIFIER ()
-> $$ = nterm operation2 ()
Stack now 0 2 81 336
Entering state 538
Next token is token keyword_do ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 81 336 538
Entering state 676
Reducing stack by rule 246 (line 2426):
   $1 = nterm none ()
-> $$ = nterm opt_paren_args ()
Stack now 0 2 81 336 538
Entering state 674
Reducing stack by rule 404 (line 3635):
   $1 = nterm primary_value ()
   $2 = token '.' ()
   $3 = nterm operation2 ()
   $4 = nterm opt_paren_args ()
-> $$ = nterm method_call ()
Stack now 0 2
Entering state 93
Next token is token keyword_do ()
Shifting token keyword_do ()
Entering state 380
Reducing stack by rule 414 (line 3735):
-> $$ = nterm @28 ()
Stack now 0 2 93 380
Entering state 576
Reading a token: Next token is token '|' ()
Shifting token '|' ()
Entering state 653
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 761
Reading a token: Next token is token '|' ()
Reducing stack by rule 518 (line 4543):
   $1 = token tIDENTIFIER ()
-> $$ = nterm f_norm_arg ()
Stack now 0 2 93 380 576 653
Entering state 636
Reducing stack by rule 519 (line 4550):
   $1 = nterm f_norm_arg ()
-> $$ = nterm f_arg_item ()
Stack now 0 2 93 380 576 653
Entering state 637
Reducing stack by rule 521 (line 4578):
   $1 = nterm f_arg_item ()
-> $$ = nterm f_arg ()
Stack now 0 2 93 380 576 653
Entering state 765
Next token is token '|' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 653 765
Entering state 748
Reducing stack by rule 537 (line 4723):
   $1 = nterm none ()
-> $$ = nterm opt_f_block_arg ()
Stack now 0 2 93 380 576 653 765
Entering state 850
Reducing stack by rule 372 (line 3377):
   $1 = nterm f_arg ()
   $2 = nterm opt_f_block_arg ()
-> $$ = nterm block_param ()
Stack now 0 2 93 380 576 653
Entering state 763
Next token is token '|' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 653 763
Entering state 770
Reducing stack by rule 385 (line 3479):
   $1 = nterm none ()
-> $$ = nterm opt_bv_decl ()
Stack now 0 2 93 380 576 653 763
Entering state 847
Next token is token '|' ()
Shifting token '|' ()
Entering state 905
Reducing stack by rule 384 (line 3468):
   $1 = token '|' ()
   $2 = nterm block_param ()
   $3 = nterm opt_bv_decl ()
   $4 = token '|' ()
-> $$ = nterm block_param_def ()
Stack now 0 2 93 380 576
Entering state 655
Reducing stack by rule 381 (line 3444):
   $1 = nterm block_param_def ()
-> $$ = nterm opt_block_param ()
Stack now 0 2 93 380 576
Entering state 716
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 35
Reading a token: Next token is token tIDENTIFIER ()
Reducing stack by rule 547 (line 4818):
   $1 = token tIDENTIFIER ()
-> $$ = nterm operation ()
Stack now 0 2 93 380 576 716
Entering state 110
Next token is token tIDENTIFIER ()
Reducing stack by rule 258 (line 2499):
-> $$ = nterm @7 ()
Stack now 0 2 93 380 576 716 110
Entering state 219
Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 35
Reading a token: Next token is token '\n' ()
Reducing stack by rule 474 (line 4275):
   $1 = token tIDENTIFIER ()
-> $$ = nterm user_variable ()
Stack now 0 2 93 380 576 716 110 219
Entering state 209
Next token is token '\n' ()
Reducing stack by rule 486 (line 4291):
   $1 = nterm user_variable ()
-> $$ = nterm var_ref ()
Stack now 0 2 93 380 576 716 110 219
Entering state 107
Reducing stack by rule 276 (line 2622):
   $1 = nterm var_ref ()
-> $$ = nterm primary ()
Stack now 0 2 93 380 576 716 110 219
Entering state 80
Next token is token '\n' ()
Reducing stack by rule 239 (line 2375):
   $1 = nterm primary ()
-> $$ = nterm arg ()
Stack now 0 2 93 380 576 716 110 219
Entering state 203
Next token is token '\n' ()
Reducing stack by rule 240 (line 2381):
   $1 = nterm arg ()
-> $$ = nterm arg_value ()
Stack now 0 2 93 380 576 716 110 219
Entering state 204
Next token is token '\n' ()
Reducing stack by rule 263 (line 2531):
   $1 = nterm arg_value ()
-> $$ = nterm args ()
Stack now 0 2 93 380 576 716 110 219
Entering state 207
Next token is token '\n' ()
Reducing stack by rule 572 (line 4874):
-> $$ = nterm none ()
Stack now 0 2 93 380 576 716 110 219 207
Entering state 398
Reducing stack by rule 262 (line 2525):
   $1 = nterm none ()
-> $$ = nterm opt_block_arg ()
Stack now 0 2 93 380 576 716 110 219 207
Entering state 397
Reducing stack by rule 254 (line 2463):
   $1 = nterm args ()
   $2 = nterm opt_block_arg ()
-> $$ = nterm call_args ()
Stack now 0 2 93 380 576 716 110 219
Entering state 409
Reducing stack by rule 259 (line 2499):
   $1 = nterm @7 ()
   $2 = nterm call_args ()
-> $$ = nterm command_args ()
Stack now 0 2 93 380 576 716 110
Entering state 387
Next token is token '\n' ()
Reducing stack by rule 58 (line 1344):
   $1 = nterm operation ()
   $2 = nterm command_args ()
-> $$ = nterm command ()
Stack now 0 2 93 380 576 716
Entering state 72
Next token is token '\n' ()
Reducing stack by rule 51 (line 1297):
   $1 = nterm command ()
-> $$ = nterm command_call ()
Stack now 0 2 93 380 576 716
Entering state 70
Reducing stack by rule 44 (line 1249):
   $1 = nterm command_call ()
-> $$ = nterm expr ()
Stack now 0 2 93 380 576 716
Entering state 69
Next token is token '\n' ()
Reducing stack by rule 41 (line 1225):
   $1 = nterm expr ()
-> $$ = nterm stmt ()
Stack now 0 2 93 380 576 716
Entering state 245
Next token is token '\n' ()
Reducing stack by rule 14 (line 933):
   $1 = nterm stmt ()
-> $$ = nterm stmts ()
Stack now 0 2 93 380 576 716
Entering state 244
Next token is token '\n' ()
Shifting token '\n' ()
Entering state 289
Reducing stack by rule 569 (line 4866):
   $1 = token '\n' ()
-> $$ = nterm term ()
Stack now 0 2 93 380 576 716 244
Entering state 291
Reducing stack by rule 570 (line 4869):
   $1 = nterm term ()
-> $$ = nterm terms ()
Stack now 0 2 93 380 576 716 244
Entering state 433
Reading a token: Next token is token keyword_end ()
Reducing stack by rule 560 (line 4847):
   $1 = nterm terms ()
-> $$ = nterm opt_terms ()
Stack now 0 2 93 380 576 716 244
Entering state 432
Reducing stack by rule 12 (line 913):
   $1 = nterm stmts ()
   $2 = nterm opt_terms ()
-> $$ = nterm compstmt ()
Stack now 0 2 93 380 576 716
Entering state 817
Next token is token keyword_end ()
Shifting token keyword_end ()
Entering state 881
Reducing stack by rule 415 (line 3734):
   $1 = token keyword_do ()
   $2 = nterm @28 ()
   $3 = nterm opt_block_param ()
   $4 = nterm compstmt ()
   $5 = token keyword_end ()
-> $$ = nterm brace_block ()
Stack now 0 2 93
Entering state 382
Reducing stack by rule 298 (line 2781):
   $1 = nterm method_call ()
   $2 = nterm brace_block ()
-> $$ = nterm primary ()
Stack now 0 2
Entering state 80
Reading a token: Next token is token '\n' ()
Reducing stack by rule 239 (line 2375):
   $1 = nterm primary ()
-> $$ = nterm arg ()
Stack now 0 2
Entering state 79
Next token is token '\n' ()
Reducing stack by rule 49 (line 1282):
   $1 = nterm arg ()
-> $$ = nterm expr ()
Stack now 0 2
Entering state 69
Next token is token '\n' ()
Reducing stack by rule 41 (line 1225):
   $1 = nterm expr ()
-> $$ = nterm stmt ()
Stack now 0 2
Entering state 67
Next token is token '\n' ()
Reducing stack by rule 8 (line 855):
   $1 = nterm stmt ()
-> $$ = nterm top_stmt ()
Stack now 0 2
Entering state 66
Reducing stack by rule 5 (line 833):
   $1 = nterm top_stmt ()
-> $$ = nterm top_stmts ()
Stack now 0 2
Entering state 65
Next token is token '\n' ()
Shifting token '\n' ()
Entering state 289
Reducing stack by rule 569 (line 4866):
   $1 = token '\n' ()
-> $$ = nterm term ()
Stack now 0 2 65
Entering state 291
Reducing stack by rule 570 (line 4869):
   $1 = nterm term ()
-> $$ = nterm terms ()
Stack now 0 2 65
Entering state 292
Reading a token: Now at end of input.
Reducing stack by rule 560 (line 4847):
   $1 = nterm terms ()
-> $$ = nterm opt_terms ()
Stack now 0 2 65
Entering state 290
Reducing stack by rule 3 (line 813):
   $1 = nterm top_stmts ()
   $2 = nterm opt_terms ()
-> $$ = nterm top_compstmt ()
Stack now 0 2
Entering state 64
Reducing stack by rule 2 (line 782):
   $1 = nterm @1 ()
   $2 = nterm top_compstmt ()
-> $$ = nterm program ()
Stack now 0
Entering state 1
Now at end of input.
Stack now 0 1
Cleanup: popping nterm program ()
						</code></pre>
					</section>
					<section>
						<h3>Ripper.sexp</h3>
						<pre><code>
require 'ripper'
require 'pp'
code = &lt;&lt;STR
  10.times do |n|
    puts n
  end
STR
puts code
pp Ripper.sexp(code)
						</code></pre>
					</section>
					<section>
						<pre><code>
[:program,
 [[:method_add_block,
   [:call, [:@int, "10", [1, 3]], :".", [:@ident, "times", [1, 6]]],
   [:do_block,
    [:block_var,
     [:params, [[:@ident, "n", [1, 16]]], nil, nil, nil, nil],
     nil],
    [[:command,
      [:@ident, "puts", [2, 0]],
      [:args_add_block, [[:var_ref, [:@ident, "n", [2, 5]]]], false]]]]]]]
						</code></pre>
					</section>
					<section>
						<h3>ruby --dump parsetree</h3>
						<pre><code>
@ NODE_SCOPE (line: 3)
+- nd_tbl: (empty)
+- nd_args:
|   (null node)
+- nd_body:
    @ NODE_ITER (line: 1)
    +- nd_iter:
    |   @ NODE_CALL (line: 1)
    |   +- nd_mid: :times
    |   +- nd_recv:
    |   |   @ NODE_LIT (line: 1)
    |   |   +- nd_lit: 10
    |   +- nd_args:
    |       (null node)
    +- nd_body:
        @ NODE_SCOPE (line: 3)
        +- nd_tbl: :n
        +- nd_args:
        |   @ NODE_ARGS (line: 1)
        |   +- nd_frml: 1
        |   +- nd_next:
        |   |   @ NODE_ARGS_AUX (line: 1)
        |   |   +- nd_rest: (null)
        |   |   +- nd_body: (null)
        |   |   +- nd_next:
        |   |       (null node)
        |   +- nd_opt:
        |       (null node)
        +- nd_body:
            @ NODE_FCALL (line: 2)
            +- nd_mid: :puts
            +- nd_args:
                @ NODE_ARRAY (line: 2)
                +- nd_alen: 1
                +- nd_head:
                |   @ NODE_DVAR (line: 2)
                |   +- nd_vid: :n
                +- nd_next:
                    (null node)
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Compilation</h1>
					</section>
					<section>
						<h3>Ruby 1.8</h3>
						<img src="img/ruby-18-layers.png" />
					</section>
					<section>
						<h3>Ruby 1.9 &amp; 2.0</h3>
						<img src="img/ruby-19-20-layers.png" />
					</section>
					<section>
						<h3>Benchmark</h3>
						<pre><code>
i= 0
while i &lt; ARGV[0].to_i
  i += 1
end
						</code></pre>
					</section>
					<section>
						<h3>logarithmic scale</h3>
						<img src="img/ruby-logarithmic-performance.png" />
					</section>
					<section>
						<h3>linear scale</h3>
						<img src="img/ruby-linear-performance.png" />
					</section>
					<section>
						<h3>iseq_compile_each in compile.c</h3>
						<aside class="notes">
							<p>compile.c:6933</p>
						</aside>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code>
code = &lt;&lt;-RUBY
  puts 1 + 2
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<h3>Compiled</h3>
						<pre><code>
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
0000 trace            1                                               (   1)
0002 putself
0003 putobject_OP_INT2FIX_O_1_C_
0004 putobject        2
0006 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
0008 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0010 leave
						</code></pre>
						<aside class="notes">
							Stack machine
						</aside>
					</section>
					<section>
						<h3>Example 2</h3>
						<pre><code>
code = &lt;&lt;-RUBY
  10.times do |n|
    puts n
  end
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<h3>Compiled</h3>
						<pre><code style="max-height: inherit;">
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
== catch table
| catch type: break  st: 0002 ed: 0006 sp: 0000 cont: 0006
|------------------------------------------------------------------------
0000 trace            1                                               (   1)
0002 putobject        10
0004 send             &lt;callinfo!mid:times, argc:0, block:block in &lt;compiled&gt;&gt;
0006 leave
== disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
== catch table
| catch type: redo   st: 0000 ed: 0009 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0009 sp: 0000 cont: 0009
|------------------------------------------------------------------------
local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
[ 2] n&lt;Arg&gt;
0000 trace            256                                             (   1)
0002 trace            1                                               (   2)
0004 putself
0005 getlocal_OP__WC__0 2
0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0009 trace            512                                             (   3)
0011 leave                                                            (   2)
						</code></pre>
						<aside class="notes">
							Local variable
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Execution</h1>
						<h3>As double stack machine</h3>
					</section>
					<section>
						<h3>rb_control_frame_t</h3>
						<img src="img/rb_control_frame_t-1.png" />
					</section>
					<section>
						<h3>caller</h3>
						<img src="img/rb_control_frame_t-2.png" />
					</section>
					<section>
						<h3>Example</h3>
						<pre><code>
10.times do
  puts "The quick brown fox jumps over the lazy dog."
end
						</code></pre>
					</section>
					<section>
						<img src="img/rb_control_frame_t-3.png" />
					</section>
					<section>
						<h3>Local Variable Access</h3>
					</section>
					<section>
						<h3>Environment Pointer</h3>
						<img src="img/local_variable_1.png" />
						<aside class="notes">
							EP = SP - 1
							Special: to track information related to blocks(rb_block_t).
						</aside>
					</section>
					<section>
						<img src="img/local_variable_2.png" />
						<aside class="notes">
							<p>Local variable table is not a table(Just like C)</p>
							<p>svar: pointer to special variable table</p>
							<p>cref: pointer to current lexical scope</p>
							<p>Method Arguments Are Treated Like Local Variables</p>
						</aside>
					</section>
					<section>
						<h3>Dynamic Variable Access</h3>
						<pre><code>
code = &lt;&lt;-RUBY
  def display_string
    str = "Dynamic access."
    10.times do
      puts str
    end
  end
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<pre><code style="max-height: inherit;">
== disasm: &lt;RubyVM::InstructionSequence:f@&lt;compiled&gt;&gt;===================
== catch table
| catch type: break  st: 0010 ed: 0014 sp: 0000 cont: 0014
|------------------------------------------------------------------------
local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 2] str
0000 trace            8                                               (   1)
0002 trace            1                                               (   2)
0004 putstring        "Dynamic access."
0006 setlocal_OP__WC__0 2
0008 trace            1                                               (   3)
0010 putobject        10
0012 send             &lt;callinfo!mid:times, argc:0, block:block in f&gt;
0014 trace            16                                              (   6)
0016 leave                                                            (   3)
== disasm: &lt;RubyVM::InstructionSequence:block in f@&lt;compiled&gt;&gt;==========
== catch table
| catch type: redo   st: 0000 ed: 0009 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0009 sp: 0000 cont: 0009
|------------------------------------------------------------------------
0000 trace            256                                             (   3)
0002 trace            1                                               (   4)
0004 putself
0005 getlocal_OP__WC__1 2
0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0009 trace            512                                             (   5)
0011 leave                                                            (   4)
						</code></pre>
					</section>
					<section>
						<img src="img/dynamic_variable.png" />
					</section>
					<section>
						<h3>Special Variable Access</h3>
					</section>
					<section>
						<h3>Guess?</h3>
						<pre><code>
str = "The quick brown fox jumped over the lazy dog.\n"
/fox/.match(str)
def search(str)
  /dog/.match(str)
  puts "Value of $&amp; inside method: \#{$&amp;}"
end
search(str)
puts "Value of $&amp; in the top level scope: \#{$&amp;}"
						</code></pre>
						<aside class="notes">
							Guess: What's the answer?
						</aside>
					</section>
					<section>
						<img src="img/special_variable_1.png" />
					</section>
					<section>
						<h3>Guess Again?</h3>
						<pre><code>
str = "The quick brown fox jumped over the lazy dog.\n"
/fox/.match(str)
2.times do
  /dog/.match(str)
  puts "Value of $&amp; inside block: \#{$&amp;}"
end
puts "Value of $&amp; in the top level scope: \#{$&amp;}"
						</code></pre>
						<aside class="notes">
							Guess: What's the answer?
						</aside>
					</section>
					<section>
						<img src="img/special_variable_2.png" />
					</section>
					<section>
						<h3>YARV Instruments Definitions</h3>
						<aside class="notes">
							<div>tool/insns2vm.rb</div>
							<div>insns.def</div>
							<div>vm.inc</div>
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h1>Control Structures</h1>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code>
code = &lt;&lt;-RUBY
  i = 0
  while i &lt; 20
    if i &lt; 10
      puts 'small'
    else
      for j in 0..3
        puts "large \#{j}"
      end
    end
    i += 1
  end
  puts 'done'
RUBY

puts RubyVM::InstructionSequence.compile(code).disasm
						</code></pre>
					</section>
					<section>
						<pre><code>
== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
== catch table
| catch type: break  st: 0035 ed: 0039 sp: 0000 cont: 0039
| catch type: break  st: 0013 ed: 0058 sp: 0000 cont: 0058
| catch type: next   st: 0013 ed: 0058 sp: 0000 cont: 0010
| catch type: redo   st: 0013 ed: 0058 sp: 0000 cont: 0013
|------------------------------------------------------------------------
local table (size: 3, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 3] i          [ 2] j
0000 trace            1                                               (   1)
0002 putobject_OP_INT2FIX_O_0_C_
0003 setlocal_OP__WC__0 3
0005 trace            1                                               (   2)
0007 jump             49
0009 putnil
0010 pop
0011 jump             49
0013 trace            1                                               (   3)
0015 getlocal_OP__WC__0 3
0017 putobject        10
0019 opt_lt           &lt;callinfo!mid:&lt;, argc:1, ARGS_SKIP&gt;
0021 branchunless     33
0023 trace            1                                               (   4)
0025 putself
0026 putstring        "small"
0028 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0030 pop
0031 jump             40                                              (   3)
0033 trace            1                                               (   6)
0035 putobject        0..3
0037 send             &lt;callinfo!mid:each, argc:0, block:block in &lt;compiled&gt;&gt;
0039 pop
0040 trace            1                                               (  10)
0042 getlocal_OP__WC__0 3
0044 putobject_OP_INT2FIX_O_1_C_
0045 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
0047 setlocal_OP__WC__0 3
0049 getlocal_OP__WC__0 3                                             (   2)
0051 putobject        20
0053 opt_lt           &lt;callinfo!mid:&lt;, argc:1, ARGS_SKIP&gt;
0055 branchif         13
0057 putnil
0058 pop
0059 trace            1                                               (  12)
0061 putself
0062 putstring        "done"
0064 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0066 leave
== disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
== catch table
| catch type: redo   st: 0004 ed: 0018 sp: 0000 cont: 0004
| catch type: next   st: 0004 ed: 0018 sp: 0000 cont: 0018
|------------------------------------------------------------------------
local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
[ 2] ?&lt;Arg&gt;
0000 getlocal_OP__WC__0 2                                             (   8)
0002 setlocal_OP__WC__1 2                                             (   6)
0004 trace            256
0006 trace            1                                               (   7)
0008 putself
0009 putobject        "large "
0011 getlocal_OP__WC__1 2
0013 tostring
0014 concatstrings    2
0016 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
0018 trace            512                                             (   8)
0020 leave                                                            (   7)
						</code></pre>
					</section>
					<section>
						<h3>Catch table</h3>
						<img src="img/catch_table.png" />
					</section>
				</section>
				<section>
					<section>
						<h1>Objects &amp; Class</h1>
					</section>
					<section>
						<h3>RObject</h3>
						<img src="img/r_object.png" />
						<aside class="notes">
							<p>At the top of the figure is a pointer to the RObject structure. (Internally, Ruby always refers to any value with a VALUE pointer.) Below this pointer, the RObject structure contains an inner RBasic structure and information spe- cific to custom objects. The RBasic sec- tion contains information that all values use: a set of Boolean values called flags that store a variety of internal technical values, and a class pointer called klass.</p>
							<p>The class pointer indicates which class an object is an instance of. In the RObject section, Ruby saves an array of instance variables that each object contains, using numiv, the instance variable count, and ivptr, a pointer to an array of values.</p>
                            <p>RBasic: includes/ruby/ruby.h:747</p>
                            <p>RObject: includes/ruby/ruby.h:762</p>
						</aside>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code>
class Mathematician
  attr_accessor :first_name
  attr_accessor :last_name
end

euler = Mathematician.new
euler.first_name = 'Leonhard'
euler.last_name = 'Euler'

euclid = Mathematician.new
euclid.first_name = 'Euclid'
						</code></pre>
					</section>
					<section>
						<img src="img/r_object_example.png" />
					</section>
                    <section>
                        <h3>Instance Variable Access</h3>
                        <img src="img/instance_variable_1.png" />
                        <img src="img/instance_variable_2.png" />
                        <aside class="notes">
                            <ul>
                                <li>In Ruby 1.8, RObject stores instance variables as a hashmap.</li>
                                <li>In Ruby 1.9, RObject just stores values of instance variables in an Array, and RClass stores names of them. Use index to connect them.</li>
                                <li>Instance variable values table will preallocate more space.</li>
                        </aside>
                    </section>
					<section>
						<h3>Generic Objects</h3>
						<img src="img/generic_objects.png" />
					</section>
					<section>
						<h3>Fixnum</h3>
						<img src="img/fixnum_object.png" />
						<aside class="notes">
							Symbol, NilClass, TrueClass, FalseClass has their owned flags.
						</aside>
					</section>
					<section>
						<h3>How do generic objects have instance variables?</h3>
						<img src="img/generic_iv_tbl.png" />
						<aside class="notes">
							All generic objects don't have their owned numiv and ivptr. Ruby saves it in a special hash called generic_iv_tbl. This hash maintains a map between generic objects and pointers to other hashes that contain each objectâ€™s instance variables.
						</aside>
					</section>
                    <section>
                        <h3>RClass</h3>
                        <img src="img/r_class.png" />
                        <aside class="notes">
                            <p>RClass: include/ruby/ruby.h:790</p>
                            <p>rb_classext_struct: internal.h:264</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Class Instance Variable Access</h3>
                        <img src="img/class_instance_variable.png" />
                    </section>
                    <section>
                        <h3>Class Variable Access</h3>
                        <img src="img/class_variable.png" />
                    </section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
